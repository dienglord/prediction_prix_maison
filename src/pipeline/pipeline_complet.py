import sys
from pathlib import Path
import logging
from datetime import datetime

# Ajouter le chemin src au Python path
current_dir = Path(__file__).resolve().parent
project_root = current_dir.parents[1]
sys.path.append(str(project_root))

# Imports des modules du projet
from src.data.collecteur_donnees import CollecteurDonnees
from src.data.preprocesseur import PreprocesseurDonnees
from src.models.entraineur import EntraineurModeles

class PipelineComplet:
    """
    Pipeline complet pour le projet de pr√©diction de prix de maisons.
    Phase 1 - Baseline simple et efficace.
    """
    
    def __init__(self, racine_projet: Path = None):
        """
        Initialise le pipeline complet.
        
        Args:
            racine_projet: Chemin vers la racine du projet
        """
        if racine_projet is None:
            self.racine_projet = Path(__file__).resolve().parents[2]
        else:
            self.racine_projet = Path(racine_projet)
        
        # Setup logging
        self.setup_logging()
        
        # Initialiser les composants
        self.collecteur = None
        self.preprocesseur = None
        self.entraineur = None
        
        self.logger.info(f"üöÄ Pipeline initialis√© - Racine: {self.racine_projet}")
    
    def setup_logging(self):
        """Configure le syst√®me de logging global."""
        logs_dir = self.racine_projet / "reports"
        logs_dir.mkdir(exist_ok=True)
        
        # Nom de fichier avec timestamp
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        log_filename = f"pipeline_complet_{timestamp}.log"
        
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(logs_dir / log_filename, encoding='utf-8'),
                logging.StreamHandler(sys.stdout)
            ]
        )
        
        self.logger = logging.getLogger("pipeline_complet")
    
    def etape_collecte_donnees(self, nom_fichier_raw: str = "data.csv") -> bool:
        """
        √âtape 1: Collecte et nettoyage des donn√©es.
        
        Args:
            nom_fichier_raw: Nom du fichier de donn√©es brutes
            
        Returns:
            bool: Succ√®s de l'√©tape
        """
        self.logger.info("=" * 50)
        self.logger.info("üìä √âTAPE 1: COLLECTE ET NETTOYAGE DES DONN√âES")
        self.logger.info("=" * 50)
        
        try:
            # Initialiser le collecteur
            self.collecteur = CollecteurDonnees(self.racine_projet)
            
            # Charger les donn√©es brutes
            self.logger.info(f"Chargement des donn√©es: {nom_fichier_raw}")
            donnees_brutes = self.collecteur.charger_donnees_raw(nom_fichier_raw, "csv")
            
            # Analyser les donn√©es
            analyse = self.collecteur.analyser_donnees(donnees_brutes)
            self.logger.info(f"Donn√©es brutes: {analyse['nb_lignes']} lignes, {analyse['nb_colonnes']} colonnes")
            
            # Nettoyer les donn√©es
            donnees_clean = self.collecteur.nettoyer_donnees(donnees_brutes)
            
            # Sauvegarder les donn√©es nettoy√©es
            self.collecteur.sauvegarder_donnees(donnees_clean, "data_clean.csv")
            
            self.logger.info("‚úÖ √âtape 1 termin√©e avec succ√®s")
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur dans l'√©tape 1: {str(e)}")
            return False
    
    def etape_preprocessing(self) -> bool:
        """
        √âtape 2: Pr√©processing et feature engineering.
        
        Returns:
            bool: Succ√®s de l'√©tape
        """
        self.logger.info("=" * 50)
        self.logger.info("üîß √âTAPE 2: PREPROCESSING ET FEATURE ENGINEERING")
        self.logger.info("=" * 50)
        
        try:
            # Initialiser le pr√©processeur
            self.preprocesseur = PreprocesseurDonnees(self.racine_projet)
            
            # Charger les donn√©es nettoy√©es
            self.logger.info("Chargement des donn√©es nettoy√©es...")
            donnees_clean = self.preprocesseur.charger_donnees("data_clean.csv", "processed")
            
            # Preprocessing complet
            self.logger.info("Preprocessing des donn√©es...")
            donnees_preprocessees = self.preprocesseur.fit_transform(donnees_clean, "price")
            
            # Division des donn√©es
            self.logger.info("Division des donn√©es...")
            X_train, X_val, X_test, y_train, y_val, y_test = self.preprocesseur.diviser_donnees(donnees_preprocessees)
            
            # Sauvegarder tout
            self.logger.info("Sauvegarde des datasets...")
            processed_dir = self.racine_projet / "data" / "processed"
            
            donnees_preprocessees.to_csv(processed_dir / "donnees_preprocessees.csv", index=False)
            X_train.to_csv(processed_dir / "X_train.csv", index=False)
            X_val.to_csv(processed_dir / "X_val.csv", index=False)
            X_test.to_csv(processed_dir / "X_test.csv", index=False)
            y_train.to_csv(processed_dir / "y_train.csv", index=False)
            y_val.to_csv(processed_dir / "y_val.csv", index=False)
            y_test.to_csv(processed_dir / "y_test.csv", index=False)
            
            # Sauvegarder le pr√©processeur
            self.preprocesseur.sauvegarder_preprocesseur()
            
            self.logger.info(f"‚úÖ √âtape 2 termin√©e: {donnees_preprocessees.shape} ‚Üí Train({len(X_train)}) Val({len(X_val)}) Test({len(X_test)})")
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur dans l'√©tape 2: {str(e)}")
            return False
    
    def etape_entrainement(self) -> bool:
        """
        √âtape 3: Entra√Ænement et √©valuation des mod√®les.
        
        Returns:
            bool: Succ√®s de l'√©tape
        """
        self.logger.info("=" * 50)
        self.logger.info("ü§ñ √âTAPE 3: ENTRA√éNEMENT ET √âVALUATION")
        self.logger.info("=" * 50)
        
        try:
            # Initialiser l'entra√Æneur
            self.entraineur = EntraineurModeles(self.racine_projet)
            
            # Charger les donn√©es pr√©process√©es
            self.logger.info("Chargement des donn√©es pr√©process√©es...")
            X_train, X_val, X_test, y_train, y_val, y_test = self.entraineur.charger_donnees_preprocessees()
            
            # Entra√Æner tous les mod√®les
            self.logger.info("Entra√Ænement de tous les mod√®les...")
            resultats = self.entraineur.entrainer_tous_modeles(X_train, y_train, X_val, y_val)
            
            # √âvaluation finale sur le test
            self.logger.info("√âvaluation finale...")
            metriques_test = self.entraineur.evaluer_sur_test(X_test, y_test)
            
            # Cr√©er le rapport de comparaison
            rapport = self.entraineur.creer_rapport_comparaison()
            
            # Sauvegarder le mod√®le et les r√©sultats
            self.logger.info("Sauvegarde des r√©sultats...")
            self.entraineur.sauvegarder_modele()
            self.entraineur.creer_visualisations()
            
            # Sauvegarder le rapport
            rapport.to_csv(self.racine_projet / "reports" / "comparaison_modeles.csv", index=False)
            
            self.logger.info(f"‚úÖ √âtape 3 termin√©e: Meilleur mod√®le = {self.entraineur.meilleur_modele} (R¬≤ = {self.entraineur.meilleur_score:.4f})")
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur dans l'√©tape 3: {str(e)}")
            return False
    
    def creer_rapport_final(self) -> None:
        """Cr√©e un rapport final du pipeline."""
        self.logger.info("=" * 50)
        self.logger.info("üìù CR√âATION DU RAPPORT FINAL")
        self.logger.info("=" * 50)
        
        try:
            rapport_final = []
            rapport_final.append("# RAPPORT FINAL - PIPELINE PR√âDICTION PRIX MAISONS")
            rapport_final.append("## Phase 1 - Baseline")
            rapport_final.append("")
            rapport_final.append(f"**Date d'ex√©cution:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
            rapport_final.append("")
            
            # Informations sur les donn√©es
            if self.collecteur:
                rapport_final.append("## üìä DONN√âES")
                # Ici on pourrait ajouter plus de statistiques
                rapport_final.append("- Source: data.csv")
                rapport_final.append("- Nettoyage: Valeurs manquantes et doublons trait√©s")
                rapport_final.append("")
            
            # Informations sur le preprocessing
            if self.preprocesseur:
                rapport_final.append("## üîß PREPROCESSING")
                rapport_final.append(f"- Colonnes num√©riques: {len(self.preprocesseur.colonnes_numeriques)}")
                rapport_final.append(f"- Colonnes cat√©gorielles (Label): {len(self.preprocesseur.colonnes_categoriques)}")
                rapport_final.append(f"- Colonnes cat√©gorielles (One-Hot): {len(self.preprocesseur.colonnes_a_encoder)}")
                rapport_final.append("- Feature engineering: Prix/m¬≤, √¢ge maison, ratios")
                rapport_final.append("- Normalisation: StandardScaler")
                rapport_final.append("")
            
            # Informations sur l'entra√Ænement
            if self.entraineur:
                rapport_final.append("## ü§ñ MOD√àLES")
                rapport_final.append(f"- Mod√®les test√©s: {len(self.entraineur.modeles)}")
                rapport_final.append(f"- Meilleur mod√®le: {self.entraineur.meilleur_modele}")
                rapport_final.append(f"- Score R¬≤ validation: {self.entraineur.meilleur_score:.4f}")
                rapport_final.append("")
            
            # Instructions d'utilisation
            rapport_final.append("## üöÄ UTILISATION")
            rapport_final.append("1. **API:** `python src/api/app.py`")
            rapport_final.append("2. **Documentation:** http://localhost:8000/docs")
            rapport_final.append("3. **Pr√©diction:** POST /predict avec les features")
            rapport_final.append("")
            
            # Fichiers g√©n√©r√©s
            rapport_final.append("## üìÅ FICHIERS G√âN√âR√âS")
            rapport_final.append("- `models/modele_*.pkl` - Meilleur mod√®le")
            rapport_final.append("- `models/preprocesseur.pkl` - Pr√©processeur")
            rapport_final.append("- `data/processed/` - Datasets pr√©process√©s")
            rapport_final.append("- `reports/` - Logs et visualisations")
            rapport_final.append("")
            
            # Prochaines √©tapes
            rapport_final.append("## üîÆ PHASE 2 - MLOPS")
            rapport_final.append("- Configuration YAML")
            rapport_final.append("- Tracking MLflow")
            rapport_final.append("- Tests automatis√©s")
            rapport_final.append("- CI/CD GitHub Actions")
            rapport_final.append("- Monitoring en production")
            rapport_final.append("- Containerisation Docker")
            
            # Sauvegarder le rapport
            rapport_path = self.racine_projet / "reports" / "rapport_final.md"
            with open(rapport_path, 'w', encoding='utf-8') as f:
                f.write('\n'.join(rapport_final))
            
            self.logger.info(f"‚úÖ Rapport final cr√©√©: {rapport_path}")
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur lors de la cr√©ation du rapport: {str(e)}")
    
    def executer_pipeline_complet(self, nom_fichier_raw: str = "data.csv") -> bool:
        """
        Ex√©cute le pipeline complet de bout en bout.
        
        Args:
            nom_fichier_raw: Nom du fichier de donn√©es brutes
            
        Returns:
            bool: Succ√®s du pipeline complet
        """
        self.logger.info("üöÄ" * 20)
        self.logger.info("üöÄ D√âMARRAGE DU PIPELINE COMPLET - PHASE 1 BASELINE")
        self.logger.info("üöÄ" * 20)
        
        debut = datetime.now()
        
        # √âtape 1: Collecte des donn√©es
        if not self.etape_collecte_donnees(nom_fichier_raw):
            self.logger.error("‚ùå √âchec de l'√©tape 1")
            return False
        
        # √âtape 2: Preprocessing
        if not self.etape_preprocessing():
            self.logger.error("‚ùå √âchec de l'√©tape 2")
            return False
        
        # √âtape 3: Entra√Ænement
        if not self.etape_entrainement():
            self.logger.error("‚ùå √âchec de l'√©tape 3")
            return False
        
        # Cr√©er le rapport final
        self.creer_rapport_final()
        
        # R√©sum√© final
        fin = datetime.now()
        duree = fin - debut
        
        self.logger.info("üéâ" * 20)
        self.logger.info("üéâ PIPELINE TERMIN√â AVEC SUCC√àS!")
        self.logger.info("üéâ" * 20)
        self.logger.info(f"‚è±Ô∏è  Dur√©e totale: {duree}")
        self.logger.info(f"üèÜ Meilleur mod√®le: {self.entraineur.meilleur_modele}")
        self.logger.info(f"üìä Score R¬≤: {self.entraineur.meilleur_score:.4f}")
        self.logger.info("")
        self.logger.info("üöÄ PROCHAINES √âTAPES:")
        self.logger.info("   1. Tester l'API: python src/api/app.py")
        self.logger.info("   2. Voir la doc: http://localhost:8000/docs")
        self.logger.info("   3. Phase 2 MLOps!")
        
        return True


def main():
    """Fonction principale pour ex√©cuter le pipeline complet."""
    try:
        print("üöÄ === PIPELINE COMPLET - PHASE 1 BASELINE ===")
        print()
        
        # Cr√©er le pipeline
        pipeline = PipelineComplet()
        
        # Ex√©cuter le pipeline complet
        succes = pipeline.executer_pipeline_complet("data.csv")
        
        if succes:
            print("\n‚úÖ === PIPELINE TERMIN√â AVEC SUCC√àS ===")
            print("üéØ Votre mod√®le est pr√™t √† √™tre utilis√©!")
            print("üìù Consultez reports/rapport_final.md pour plus de d√©tails")
            print()
            print("üöÄ Pour tester l'API:")
            print("   cd src/api && python app.py")
            print("   Puis allez sur: http://localhost:8000/docs")
            
            return True
        else:
            print("\n‚ùå === √âCHEC DU PIPELINE ===")
            print("Consultez les logs dans reports/ pour plus de d√©tails")
            return False
            
    except KeyboardInterrupt:
        print("\n‚ö†Ô∏è Pipeline interrompu par l'utilisateur")
        return False
        
    except Exception as e:
        print(f"\n‚ùå Erreur fatale: {str(e)}")
        return False


if __name__ == "__main__":
    succes = main()
    sys.exit(0 if succes else 1)